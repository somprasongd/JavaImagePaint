/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.github.somprasongd.java.paint.components;

import com.github.somprasongd.java.paint.objects.AnnotationLineObject;
import com.github.somprasongd.java.paint.objects.AnnotationNoteObject;
import com.github.somprasongd.java.paint.objects.AnnotationObject;
import com.github.somprasongd.java.paint.objects.AnnotationOvalObject;
import com.github.somprasongd.java.paint.objects.AnnotationQuadArrowObject;
import com.github.somprasongd.java.paint.objects.AnnotationRectObject;
import com.github.somprasongd.java.paint.objects.AnnotationTextObject;
import com.github.somprasongd.java.paint.utils.BufferedImageTool;
import com.github.somprasongd.java.paint.utils.ImageIOFileFilter;
import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.MediaTracker;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.imageio.ImageWriter;
import javax.imageio.stream.FileImageOutputStream;
import javax.imageio.stream.ImageOutputStream;
import javax.swing.JFileChooser;
import javax.swing.JScrollPane;

/**
 *
 * @author sompr
 */
public class PaintPanel extends javax.swing.JPanel {

    public static final int MODE_FREE_HAND = -1;
    public static final int MODE_LINE = 0;
    public static final int MODE_SCRIBBLE = 1;
    public static final int MODE_RECT = 2;
    public static final int MODE_OVAL = 3;
    public static final int MODE_TEXT = 4;
    public static final int MODE_SELECT = 5;
    public static final int MODE_ERASE = 6;
    public static final int MODE_FLOOD = 7;
    public static final int MODE_POINT = 8;
    public static final int MODE_QUADARROW = 9;
    public static final int MODE_COLORPICK = 10;
    public static final int MODE_NOTE = 11;
    public static final int MODE_NONE = 100;

    private JScrollPane scrollPane;
    private LocationPanel locationPanel;

    private final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
    ;
    private double zoom = 1.0d;
    private List paintObjects;
    private List selectedObjects;
    private List tempObjects;
    private List displayObjects;

    private Color bgColor;
    private final int eraseRad = 3;
    private int currentMode;
    private int oldMode;
    private float alpha;
    private boolean antialiased;
    private double currentAngle;
    private boolean filled;
    private Color textColor;
    private Color drawColor;
    private Stroke stroke;

    private int img_width;
    private int img_height;
    private int new_width;
    private int new_height;

    private int arcWidth = 0;
    private int arcHeight = 0;

    private JFileChooser saveChooser;
    private File currentFile;
    private BufferedImage img;

    private Point dragDown;
    private Cursor preCursor;
    private boolean drag;
    private Point mousePoint;

    /**
     * Creates new form PaintPanel
     */
    public PaintPanel() {
        initComponents();
        reset();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                formMouseMoved(evt);
            }
        });
        addMouseWheelListener(new java.awt.event.MouseWheelListener() {
            public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt) {
                formMouseWheelMoved(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                formMouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                formMouseExited(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
        if (evt.getKeyCode() == KeyEvent.VK_DELETE) {
            deleteSelected();
        }

        for (int i = 0; i < selectedObjects.size(); i++) {
            AnnotationObject paintObject = (AnnotationObject) selectedObjects.get(i);
            paintObject.keyPressed(evt);
        }
        this.updatePanel();
    }//GEN-LAST:event_formKeyPressed

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        if (currentMode == MODE_SELECT && evt.getButton() == MouseEvent.BUTTON1) {
            boolean ctrl = (evt.getModifiers() & MouseEvent.CTRL_MASK) == MouseEvent.CTRL_MASK;
            if (!ctrl) {
                selectedObjects = new ArrayList();
            }
            AnnotationObject closest = null;
            double closestDist = Double.MAX_VALUE;
            for (Iterator iterator = paintObjects.iterator(); iterator.hasNext();) {
                AnnotationObject paintObject = (AnnotationObject) iterator.next();
                if (!ctrl) {
                    paintObject.setSelected(false);
                }
                Point2D[] points = paintObject.getHighlightPoints();
                for (Point2D point : points) {
                    double dist = point.distance(new Point2D.Double(evt.getPoint().getX() / zoom, evt.getPoint().getY() / zoom));
                    if (dist < closestDist) {
                        closest = paintObject;
                        closestDist = dist;
                    }
                }
            }
            if (closest != null) {
                if (closest.isSelected()) {
                    closest.setSelected(false);
                    selectedObjects.remove(closest);
                } else {
                    closest.setSelected(true);
                    selectedObjects.add(closest);
                    this.firePropertyChange("selection", null, selectedObjects);
                }
            }
        } else if (currentMode == MODE_COLORPICK) {
            Color color = new Color(img.getRGB((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom)));
            this.firePropertyChange("pickcolor", this.drawColor, color);
            this.setDrawColor(color);
            this.setCurrentMode(oldMode);

        }
        this.updatePanel();
    }//GEN-LAST:event_formMouseClicked

    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        this.requestFocus();
        if ((evt.getModifiersEx() & MouseEvent.BUTTON3_DOWN_MASK) == MouseEvent.BUTTON3_DOWN_MASK) {
            this.dragDown = evt.getPoint();
            this.preCursor = this.getCursor();
            this.setCursor(new Cursor(Cursor.HAND_CURSOR));
        } else if ((evt.getModifiersEx() & MouseEvent.BUTTON1_DOWN_MASK) == MouseEvent.BUTTON1_DOWN_MASK) {
            switch (currentMode) {
                case MODE_FLOOD:
                    int rgb = img.getRGB((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom));
                    this.updatePanel();
                    break;
                case MODE_OVAL:
                    tempObjects.add(new AnnotationOvalObject(this.drawColor, new Point((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom)), this.getStroke(), antialiased, filled, alpha));
                    break;
                case MODE_RECT:
                    tempObjects.add(new AnnotationRectObject(this.drawColor, new Point((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom)), this.getStroke(), antialiased, filled, arcWidth, arcHeight, alpha));
                    break;
                case MODE_LINE:
                    tempObjects.add(new AnnotationLineObject(this.drawColor, new Point((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom)), this.getStroke(), antialiased, alpha));
                    break;
                case MODE_QUADARROW:
                    tempObjects.add(new AnnotationQuadArrowObject(this.drawColor, new Point((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom)), this.getStroke(), antialiased, filled, alpha));
                    break;
                case MODE_TEXT:
                    AnnotationTextObject text = new AnnotationTextObject(this.getFont(), this.textColor, new Point((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom)), " ", antialiased);
                    text.setPanel(this);
                    tempObjects.add(text);
                    this.setCurrentMode(MODE_SELECT);
                    selectedObjects.add(text);
                    break;
                case MODE_NOTE:
                    Point2D locationStart = new Point((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom));
                    NoteDialog noteDialog = new NoteDialog(null, true);
                    AnnotationNoteObject note = noteDialog.open(locationStart, antialiased);
                    if (note != null) {
                        this.addNoteObjects(note);
                    }
                    break;
                case MODE_SELECT:
                    double closestDist = Double.MAX_VALUE;
                    if (selectedObjects.size() == 1) {
                        AnnotationObject selectedObject = (AnnotationObject) selectedObjects.get(0);
                        selectedObject.setCurrentPointIndex(-1);
                        Point2D[] points = selectedObject.getHighlightPoints();
                        for (int i = 0; i < points.length; i++) {
                            Point2D point = points[i];
                            double dist = point.distance(new Point2D.Double(evt.getPoint().getX() / zoom, evt.getPoint().getY() / zoom));
                            if (dist < closestDist) {
                                selectedObject.setCurrentPointIndex(i);
                                closestDist = dist;
                            }
                        }
                        if (closestDist < 5.0) {

                            paintObjects.remove(selectedObject);
                            tempObjects.add(selectedObject);
                        } else {
                            selectedObject.setCurrentPointIndex(-1);
                        }

                    } else {

                        for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
                            AnnotationObject paintObject = (AnnotationObject) iterator.next();
                            paintObject.setCurrentPointIndex(-1);
                            Point2D[] points = paintObject.getHighlightPoints();
                            for (Point2D point : points) {
                                double dist = point.distance(new Point2D.Double(evt.getPoint().getX() / zoom, evt.getPoint().getY() / zoom));
                                if (dist < closestDist) {
                                    closestDist = dist;
                                }
                            }
                        }

                        if (closestDist < 5.0) {
                            for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
                                AnnotationObject paintObject = (AnnotationObject) iterator.next();

                                paintObject.setCurrentPointIndex(0);
                                paintObjects.remove(paintObject);
                                tempObjects.add(paintObject);
                            }
                        }

                    }
                    break;
                case MODE_ERASE: {
                    Point loc = new Point((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom));
                    int startX = loc.x - (eraseRad - 1) / 2;
                    int startY = loc.y - (eraseRad - 1) / 2;
                    int endX = loc.x + (eraseRad - 1) / 2;
                    int endY = loc.y + (eraseRad - 1) / 2;
                    if (startX < 0) {
                        startX = 0;
                    }
                    if (startY < 0) {
                        startY = 0;
                    }
                    if (endX > img.getWidth() - 1) {
                        endX = img.getWidth() - 1;
                    }
                    if (endY > img.getHeight() - 1) {
                        endY = img.getHeight() - 1;
                    }
                    WritableRaster raster = img.getRaster();
                    for (int x = startX; x <= endX; x++) {
                        for (int y = startY; y <= endY; y++) {
                            raster.setSample(x, y, 3, 0);
                        }
                    }
                    break;
                }
                case MODE_POINT: {
                    Point loc = new Point((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom));
                    int startX = loc.x - (eraseRad - 1) / 2;
                    int startY = loc.y - (eraseRad - 1) / 2;
                    int endX = loc.x + (eraseRad - 1) / 2;
                    int endY = loc.y + (eraseRad - 1) / 2;
                    if (startX < 0) {
                        startX = 0;
                    }
                    if (startY < 0) {
                        startY = 0;
                    }
                    if (endX > img.getWidth() - 1) {
                        endX = img.getWidth() - 1;
                    }
                    if (endY > img.getHeight() - 1) {
                        endY = img.getHeight() - 1;
                    }
                    WritableRaster raster = img.getRaster();
                    for (int x = startX; x <= endX; x++) {
                        for (int y = startY; y <= endY; y++) {

                            img.setRGB(x, y, this.getDrawColor().getRGB());
                            raster.setSample(x, y, 3, (int) (255 * this.getAlpha()));

                        }
                    }
                    break;
                }
                default:
                    break;
            }
        }
        drag = false;
        this.updatePanel();
    }//GEN-LAST:event_formMousePressed

    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        if (currentMode == MODE_ERASE || currentMode == MODE_POINT) {
            mousePoint = new Point((int) (evt.getX() / zoom), (int) (evt.getY() / zoom));

        }

        if (preCursor != null) {
            this.setCursor(preCursor);
            preCursor = null;
        }
        dragDown = null;

        for (Iterator iterator = tempObjects.iterator(); iterator.hasNext();) {
            AnnotationObject tempObject = (AnnotationObject) iterator.next();

            if (tempObject.finished(new Point((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom)))) {
                paintObjects.add(tempObject);
            }
            tempObject.setStartDragLoc(null);
            tempObject.setCurrentPointIndex(-1);
        }

        for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
            AnnotationObject selObject = (AnnotationObject) iterator.next();
            selObject.setCurrentPointIndex(-1);
        }

        tempObjects = new ArrayList();

        if (evt.isPopupTrigger() & !drag & currentMode == MODE_SELECT) {

            ArrayList toDelete = new ArrayList();
            for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
                AnnotationObject paintObject = (AnnotationObject) iterator.next();
                toDelete.add(paintObject);
            }
            for (Iterator iterator = toDelete.iterator(); iterator.hasNext();) {
                AnnotationObject object = (AnnotationObject) iterator.next();

                if (object instanceof AnnotationNoteObject) {
                    AnnotationNoteObject notes = (AnnotationNoteObject) object;
                    NoteDialog noteDialog = new NoteDialog(null, true);
                    AnnotationNoteObject editedNote = noteDialog.edit(notes, antialiased);
                    if (!editedNote.equals(notes)) {
                        this.removeSelectNote(notes);
                        this.addNoteObjects(editedNote);
                    }
                }
            }
        }
        this.updatePanel();
    }//GEN-LAST:event_formMouseReleased

    private void formMouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseEntered
        if (locationPanel != null) {
            int x = (int) (evt.getX() / zoom);
            int y = (int) (evt.getY() / zoom);
            if (x >= 0 && x < img.getWidth() && y >= 0 && y < img.getHeight()) {
                locationPanel.updateLocation(new Point(x, y));
            } else {
                locationPanel.updateLocation(null);
            }

            locationPanel.repaint();
        }
        if (currentMode == MODE_ERASE || currentMode == MODE_POINT) {
            mousePoint = new Point((int) (evt.getX() / zoom), (int) (evt.getY() / zoom));
            this.updatePanel();
        }
    }//GEN-LAST:event_formMouseEntered

    private void formMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseExited
        if (locationPanel != null) {
            locationPanel.updateLocation(null);
            locationPanel.repaint();
        }
        if (currentMode == MODE_ERASE || currentMode == MODE_POINT) {
            mousePoint = null;
            this.repaint();
        }
    }//GEN-LAST:event_formMouseExited

    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        drag = true;
        if ((evt.getModifiersEx() & MouseEvent.BUTTON3_DOWN_MASK) == MouseEvent.BUTTON3_DOWN_MASK) {
            if (scrollPane != null) {
                Point current = evt.getPoint();
                int xMove = current.x - dragDown.x;
                int yMove = current.y - dragDown.y;

                Point origin = scrollPane.getViewport().getViewPosition();
                int newX = origin.x - xMove;
                int newY = origin.y - yMove;
                int xMax = this.getWidth() - scrollPane.getViewport().getWidth();
                int yMax = this.getHeight() - scrollPane.getViewport().getHeight();
                if (newX < 0) {
                    System.out.println("darg4");
                    newX = 0;
                }
                if (newY < 0) {
                    System.out.println("darg5");
                    newY = 0;
                }
                if (newX > xMax) {
                    System.out.println("darg6");
                    newX = xMax;
                }
                if (newY > yMax) {
                    System.out.println("darg7");
                    newY = yMax;
                }
                scrollPane.getViewport().setViewPosition(new Point(newX, newY));

            }

        } else if ((evt.getModifiersEx() & MouseEvent.BUTTON1_DOWN_MASK) == MouseEvent.BUTTON1_DOWN_MASK) {
            if (locationPanel != null) {
                int x = (int) (evt.getX() / zoom);
                int y = (int) (evt.getY() / zoom);
                if (x >= 0 && x < img.getWidth() && y >= 0 && y < img.getHeight()) {
                    locationPanel.updateLocation(new Point(x, y));
                } else {
                    locationPanel.updateLocation(null);
                }

                locationPanel.repaint();
            }
            switch (currentMode) {
                case MODE_ERASE: {
                    mousePoint = null;
                    Point loc = new Point((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom));
                    int startX = loc.x - (eraseRad - 1) / 2;
                    int startY = loc.y - (eraseRad - 1) / 2;
                    int endX = loc.x + (eraseRad - 1) / 2;
                    int endY = loc.y + (eraseRad - 1) / 2;
                    if (startX < 0) {
                        startX = 0;
                    }
                    if (startY < 0) {
                        startY = 0;
                    }
                    if (endX > img.getWidth() - 1) {
                        endX = img.getWidth() - 1;
                    }
                    if (endY > img.getHeight() - 1) {
                        endY = img.getHeight() - 1;
                    }
                    WritableRaster raster = img.getRaster();
                    for (int x = startX; x <= endX; x++) {
                        for (int y = startY; y <= endY; y++) {
                            //          img.setRGB(x,y,bgColor.getRGB());
                            raster.setSample(x, y, 3, 0);
                        }
                    }
                    break;
                }
                case MODE_POINT: {
                    Point loc = new Point((int) (evt.getPoint().x / zoom), (int) (evt.getPoint().y / zoom));
                    int startX = loc.x - (eraseRad - 1) / 2;
                    int startY = loc.y - (eraseRad - 1) / 2;
                    int endX = loc.x + (eraseRad - 1) / 2;
                    int endY = loc.y + (eraseRad - 1) / 2;
                    if (startX < 0) {
                        startX = 0;
                    }
                    if (startY < 0) {
                        startY = 0;
                    }
                    if (endX > img.getWidth() - 1) {
                        endX = img.getWidth() - 1;
                    }
                    if (endY > img.getHeight() - 1) {
                        endY = img.getHeight() - 1;
                    }
                    WritableRaster raster = img.getRaster();
                    for (int x = startX; x <= endX; x++) {
                        for (int y = startY; y <= endY; y++) {

                            img.setRGB(x, y, this.getDrawColor().getRGB());
                            raster.setSample(x, y, 3, (int) (255 * this.getAlpha()));
                        }
                    }
                    break;
                }
                default:
                    for (Iterator iterator = tempObjects.iterator(); iterator.hasNext();) {
                        int x = evt.getX();
                        int y = evt.getY();
                        if (x < 0) {
                            x = 0;
                        }
                        if (y < 0) {
                            y = 0;
                        }
                        if (x > this.getPreferredSize().width) {
                            x = this.getPreferredSize().width;
                        }
                        if (y > this.getPreferredSize().height) {
                            y = this.getPreferredSize().height;
                        }
                        AnnotationObject tempObject = (AnnotationObject) iterator.next();
                        if (tempObject.getStartDragLoc() == null) {
                            tempObject.setStartDragLoc(new Point((int) (x / zoom), (int) (y / zoom)));
                        }
                        tempObject.updateLocation(new Point((int) (x / zoom), (int) (y / zoom)));
                    }
                    break;
            }
        }
        this.updatePanel();
    }//GEN-LAST:event_formMouseDragged

    private void formMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseMoved
        if (locationPanel != null) {
            int x = (int) (evt.getX() / zoom);
            int y = (int) (evt.getY() / zoom);
            if (x >= 0 && x < img.getWidth() && y >= 0 && y < img.getHeight()) {
                locationPanel.updateLocation(new Point(x, y));
            } else {
                locationPanel.updateLocation(null);
            }
            locationPanel.repaint();
        }
        if (currentMode == MODE_ERASE || currentMode == MODE_POINT) {
            mousePoint = new Point((int) (evt.getX() / zoom), (int) (evt.getY() / zoom));

            this.updatePanel();
        }
    }//GEN-LAST:event_formMouseMoved

    private void formMouseWheelMoved(java.awt.event.MouseWheelEvent evt) {//GEN-FIRST:event_formMouseWheelMoved
        if (evt.getWheelRotation() > 0) {
            this.setZoom(this.getZoom() - 0.25);
        }
        if (evt.getWheelRotation() < 0) {
            //zoom++;
            this.setZoom(this.getZoom() + 0.25);
        }
        this.zoomed(evt.getPoint());
    }//GEN-LAST:event_formMouseWheelMoved


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    private void reset() {
        this.paintObjects = new ArrayList();
        this.tempObjects = new ArrayList();
        this.selectedObjects = new ArrayList();
        this.displayObjects = new ArrayList();

        setZoom(1.0d);

        // default color
        setBgColor(new Color(236, 233, 216));
        setDrawColor(Color.black);
        setTextColor(Color.black);

        setTextFont(this.getFont());

        this.setFilled(false);
        this.setStroke(new BasicStroke(1.0f));
        this.setAlpha(1.0f);
        this.setAntialiased(true);

        this.setImage((BufferedImage) null);

        this.setPreferredSize(new Dimension((int) (img.getWidth() * zoom), (int) (img.getHeight() * zoom)));
    }

    public Color getBgColor() {
        return bgColor;
    }

    public void setBgColor(Color bgColor) {
        this.bgColor = bgColor;
    }

    /**
     * Get scrollPane
     *
     * @return
     */
    public JScrollPane getScroll() {
        return scrollPane;
    }

    /**
     * Set score
     *
     * @param scroll
     */
    public void setScroll(JScrollPane scroll) {
        this.scrollPane = scroll;
    }

    /**
     * Get lacation panel
     *
     * @return
     */
    public LocationPanel getLocationPanel() {
        return locationPanel;
    }

    /**
     * Set location panel
     *
     * @param panel
     */
    public void setLocationPanel(LocationPanel panel) {
        this.locationPanel = panel;
    }

    /**
     * Get current mode
     *
     * @return current mode
     */
    public int getCurrentMode() {
        return currentMode;
    }

    public void setCurrentMode(int currentMode) {
        oldMode = currentMode;
        // set current mode
        this.currentMode = currentMode;
        // clear selected drawed objects
        selectedObjects = new ArrayList();
        switch (currentMode) {
            case MODE_LINE:
            case MODE_OVAL:
            case MODE_RECT:
                this.setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));
                break;
            case MODE_TEXT:
            case MODE_NOTE:
                this.setCursor(new Cursor(Cursor.TEXT_CURSOR));
                break;
            case MODE_SELECT:
            case MODE_QUADARROW:
                this.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
                break;
            default:
                this.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
                break;
        }
        this.updatePanel();
    }

    /**
     * Update this panel
     */
    public void updatePanel() {
        if (scrollPane != null) {
            this.revalidate();
            scrollPane.repaint();
        } else {
            this.repaint();
        }
    }

    public void setImage(URL url) {
        if (url == null) {
            return;
        }
        try {

            setImage(ImageIO.read(url));
        } catch (IOException ex) {
            Logger.getLogger(PaintPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public void setImage(File file) {
        if (file == null) {
            return;
        }
        try {

            setImage(ImageIO.read(file));
        } catch (IOException ex) {
            Logger.getLogger(PaintPanel.class.getName()).log(Level.SEVERE, null, ex);
        }

    }

    public void setImage(BufferedImage img) {
        this.img = img;
        if (this.img == null) {
            this.setImageSize(600, 420, false);
        }
        this.img = BufferedImageTool.copy(this.img);
        MediaTracker mt = new MediaTracker(this);
        mt.addImage(this.img, 0);
        try {
            mt.waitForID(0);
        } catch (InterruptedException ex) {
            Logger.getLogger(PaintPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
        this.zoom = 1;
        this.currentAngle = 0.0;
        this.setPreferredSize(new Dimension((int) (this.img.getWidth() * zoom), (int) (this.img.getHeight() * zoom)));
        this.paintObjects = new ArrayList();
        this.tempObjects = new ArrayList();
        this.selectedObjects = new ArrayList();
        this.img_width = this.img.getWidth();
        this.img_height = this.img.getHeight();
        this.setCurrentMode(MODE_NONE);
        updatePanel();
    }

    /**
     * Set image size
     */
    private void setImageSize(int width, int height, boolean copyOld) {
        BufferedImage old = img;
//        properties.setProperty("width", "" + width);
//        properties.setProperty("height", "" + height);
        img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        if (old != null && copyOld) {
            Graphics g = img.getGraphics();
            g.drawImage(old, 0, 0, null);
        }
    }

    /**
     *
     * @param g
     */
    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;

        AffineTransform origXform = g2.getTransform();
        AffineTransform newXform = (AffineTransform) (origXform.clone());

        //center of rotation is center of the image
        int xRot = (int) (img.getWidth() * zoom) / 2;
        int yRot = (int) (img.getHeight() * zoom) / 2;
        newXform.rotate(Math.toRadians(currentAngle), xRot, yRot);

        double transW = xRot - (int) (new_width * zoom) / 2;
        double transH = yRot - (int) (new_height * zoom) / 2;
        if (transW < 0) {
            transW *= -1;
        }
        if (transH < 0) {
            transH *= -1;
        }

        if (img.getWidth() - img.getHeight() > 0) {
            if (currentAngle == 90.0) {
                newXform.translate(transW * zoom, transH * zoom);
            }
            if (currentAngle == 270.0) {
                newXform.translate(-transW * zoom, -transH * zoom);
            }
        } else {
            if (currentAngle == 90.0) {
                newXform.translate(-transW * zoom, -transH * zoom);
            }
            if (currentAngle == 270.0) {
                newXform.translate(transW * zoom, transH * zoom);
            }
        }

        g2.setTransform(newXform);

        //zoomed bits
        g2.scale((double) zoom, (double) zoom);
        g2.setColor(getBgColor());
        g2.fillRect(0, 0, img.getWidth(), img.getHeight());

        //unzoomded bits
        g2.drawImage(img, 0, 0, null);
        //g2.setTransform(origXform);

        if (zoom >= 5) {
            g2.scale(1.0 / (double) zoom, 1.0 / (double) zoom);
            for (int x = 0; x < img.getWidth() * zoom; x += zoom) {
                g2.setColor(Color.lightGray);
                g2.drawLine(x, 0, x, (int) (img.getHeight() * zoom));
            }
            for (int y = 0; y < img.getHeight() * zoom; y += zoom) {
                g2.setColor(Color.lightGray);
                g2.drawLine(0, y, (int) (img.getWidth() * zoom), y);
            }
            g2.scale(zoom, zoom);
        }

        //displayObjects
        for (int i = 0; i < displayObjects.size(); i++) {
            AnnotationObject paintObject = (AnnotationObject) displayObjects.get(i);
            paintObject.addToGraphics(g2);
        }

        //paint objects
        g2.drawImage(getObjectsImage(paintObjects), 0, 0, null);
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        //paint highlight points for those objects selected
        if (currentMode == MODE_SELECT) {
            for (int o = 0; o < selectedObjects.size(); o++) {
                g2.setColor(Color.magenta);
                AnnotationObject paintObject = (AnnotationObject) selectedObjects.get(o);
                Point2D[] points = paintObject.getHighlightPoints();
                for (int i = 0; i < points.length; i++) {
                    Point2D point = points[i];
                    g2.translate(paintObject.getTranslation()[0], paintObject.getTranslation()[1]);
                    g2.setStroke(new BasicStroke((float) (1.0 / zoom)));
                    RoundRectangle2D.Double rect = new RoundRectangle2D.Double((point.getX() - 2), (point.getY() - 2), 5, 5, 2, 2);
                    g2.draw(rect);
                    g2.translate(-paintObject.getTranslation()[0], -paintObject.getTranslation()[1]);
                }
            }
        }

        //paint temp objects &  hightliged points
        for (int t = 0; t < tempObjects.size(); t++) {
            AnnotationObject tempObject = (AnnotationObject) tempObjects.get(t);
            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));
            tempObject.addToGraphics(g2);
            if (tempObject.isSelected() && currentMode == MODE_SELECT) {
                Point2D[] points = tempObject.getHighlightPoints();
                for (int i = 0; i < points.length; i++) {
                    Point2D point = points[i];
                    g2.setColor(Color.magenta);
                    g2.translate(tempObject.getTranslation()[0], tempObject.getTranslation()[1]);
                    g2.setStroke(new BasicStroke((float) (1.0 / zoom)));
                    RoundRectangle2D.Double rect = new RoundRectangle2D.Double((point.getX() - 2), (point.getY() - 2), 5, 5, 2, 2);
                    g2.draw(rect);
                    int index = tempObject.getCurrentPointIndex();
                    if (index == i) {
                        g2.fill(rect);
                    }
                    g2.translate(-tempObject.getTranslation()[0], -tempObject.getTranslation()[1]);
                }
            }
        }
    }

    /**
     * Check is antialiase or not
     *
     * @return true - if it was selected
     * <br>
     * false - in otherwise
     */
    public boolean isAntialiased() {
        return antialiased;
    }

    /**
     * Set antialiase
     *
     * @param antialiased antialiase is true when this button selected and false
     * in otherwise
     */
    public void setAntialiased(boolean antialiased) {
        this.antialiased = antialiased;
//        properties.setProperty("antialiased", "" + antialiased);
        for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
            AnnotationObject paintObject = (AnnotationObject) iterator.next();
            paintObject.setAntialiased(antialiased);
        }
        this.updatePanel();
    }

    // Zoom action
    /**
     * Set number of zoom at a time
     *
     * @param zoom number of zoom that zoomed at a time
     */
    public void setZoom(double zoom) {
        this.zoom = zoom;
        if (this.zoom < 0.25) {
            this.zoom = 0.25;
        }
        if (this.zoom > 4.75) {
            this.zoom = 4.75;
        }
    }

    /**
     * Get zoom
     *
     * @return
     */
    public double getZoom() {
        return zoom;
    }

    /**
     *
     * @param center center point of zoomed
     */
    public void zoomed(Point center) {
        Dimension newSize = new Dimension((int) (img.getWidth() * zoom), (int) (img.getHeight() * zoom));
        if (scrollPane != null) {
            Dimension currentSize = this.getPreferredSize();
            double ratio = (double) newSize.getHeight() / (double) currentSize.getHeight();

            Point currentLoc = scrollPane.getViewport().getViewPosition();

            Dimension viewSize = scrollPane.getViewport().getExtentSize();
            int xOff = center.x - currentLoc.x;
            int yOff = center.y - currentLoc.y;

            Point newCent = new Point((int) (center.x * ratio), (int) (center.y * ratio));

            int newXLoc = newCent.x - xOff;
            int newYLoc = newCent.y - yOff;
            if (newXLoc > newSize.getWidth() - viewSize.getWidth()) {
                newXLoc = (int) newSize.getWidth() - (int) viewSize.getWidth();
            }
            if (newXLoc < 0) {
                newXLoc = 0;
            }
            if (newYLoc > newSize.getHeight() - viewSize.getHeight()) {
                newYLoc = (int) newSize.getHeight() - (int) viewSize.getHeight();
            }
            if (newYLoc < 0) {
                newYLoc = 0;
            }
            Point newLoc = new Point(newXLoc, newYLoc);

            this.setPreferredSize(newSize);
            this.revalidate();
            scrollPane.getViewport().setViewPosition(newLoc);

            if (locationPanel != null) {
                int x = (int) (center.getX() / zoom);
                int y = (int) (center.getY() / zoom);

                if (x >= 0 && x < img.getWidth() && y >= 0 && y < img.getHeight()) {
                    locationPanel.updateLocation(new Point(x, y));
                } else {
                    locationPanel.updateLocation(null);
                }
                locationPanel.repaint();
            }
            this.updatePanel();
        } else {
            this.setPreferredSize(newSize);
            this.revalidate();
            this.updatePanel();
        }
    }

    /**
     * Get an alphas
     *
     * @return alpha
     */
    public float getAlpha() {
        return alpha;
    }

    /**
     * Set an alpha
     *
     * @param alpha
     */
    public void setAlpha(float alpha) {
        this.alpha = alpha;
//        properties.setProperty("alpha", "" + alpha);
        if (selectedObjects != null) {
            for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
                AnnotationObject paintObject = (AnnotationObject) iterator.next();
                paintObject.setAlpha(this.alpha);
            }
            this.updatePanel();
        }
    }

    public void deleteSelected() {
        for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
            AnnotationObject paintObject = (AnnotationObject) iterator.next();
            paintObjects.remove(paintObject);
            selectedObjects.remove(paintObject);
        }
        this.updatePanel();
    }

    /**
     * Check the button fill was selected or not
     *
     * @return true - if it was selected
     * <br>
     * false - in otherwise
     *
     */
    public boolean isFilled() {
        return filled;
    }

    /**
     * Set Filled
     *
     * @param filled fill is true when this button selected and false in
     * otherwise
     */
    public void setFilled(boolean filled) {
        this.filled = filled;
//        properties.setProperty("filled", "" + filled);
        if (selectedObjects != null) {
            for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
                AnnotationObject paintObject = (AnnotationObject) iterator.next();
                if (paintObject instanceof AnnotationRectObject) {
                    ((AnnotationRectObject) paintObject).setFilled(filled);
                    continue;
                }
                if (paintObject instanceof AnnotationOvalObject) {
                    ((AnnotationOvalObject) paintObject).setFilled(filled);
                    continue;
                }
                if (paintObject instanceof AnnotationQuadArrowObject) {
                    ((AnnotationQuadArrowObject) paintObject).setFilled(filled);
                }
            }
            this.updatePanel();
        }
    }

    /**
     * Get color of the rectangle, oval, line or arrow objects
     *
     * @return
     *
     */
    public Color getDrawColor() {
        return drawColor;
    }

    /**
     * Set color of the rectangle, oval, line or arrow objects
     *
     * @param drawColor
     */
    public void setDrawColor(Color drawColor) {
        this.drawColor = drawColor;
//        properties.setProperty("drawcolor", "" + drawColor.getRGB());
        for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
            AnnotationObject paintObject = (AnnotationObject) iterator.next();
            if (paintObject instanceof AnnotationTextObject
                    || paintObject instanceof AnnotationNoteObject) {
                continue;
            }
            paintObject.setColor(drawColor);
        }
        this.updatePanel();
    }

    /**
     * Get text's color
     *
     * @return
     */
    public Color getTextColor() {
        return textColor;
    }

    /**
     * Set text's color
     *
     * @param textColor
     */
    public void setTextColor(Color textColor) {
        this.textColor = textColor;
//        properties.setProperty("textcolor", "" + textColor.getRGB());
        for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
            AnnotationObject paintObject = (AnnotationObject) iterator.next();
            if (paintObject instanceof AnnotationTextObject) {
                paintObject.setColor(textColor);
            }
        }
        this.updatePanel();
    }

    /**
     * Get stroke
     *
     * @return
     */
    public Stroke getStroke() {
        return stroke;
    }

    /**
     * set stroke
     *
     * @param stroke
     */
    public void setStroke(Stroke stroke) {
        this.stroke = stroke;
//        properties.setProperty("stroke", "" + ((BasicStroke) stroke).getLineWidth());
        if (selectedObjects != null) {
            for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
                AnnotationObject paintObject = (AnnotationObject) iterator.next();
                if (paintObject instanceof AnnotationRectObject) {
                    ((AnnotationRectObject) paintObject).setStroke(stroke);
                    continue;
                }
                if (paintObject instanceof AnnotationOvalObject) {
                    ((AnnotationOvalObject) paintObject).setStroke(stroke);
                    continue;
                }
                if (paintObject instanceof AnnotationLineObject) {
                    ((AnnotationLineObject) paintObject).setStroke(stroke);
                    continue;
                }
                if (paintObject instanceof AnnotationQuadArrowObject) {
                    ((AnnotationQuadArrowObject) paintObject).setStroke(stroke);
                }
            }
            this.updatePanel();
        }
    }

    public void setTextFont(Font font) {
//        if (properties != null) {
//            properties.setProperty("fontname", font.getName());
//            properties.setProperty("fonttype", "" + font.getStyle());
//            properties.setProperty("fontsize", "" + font.getSize());
//        }

        if (selectedObjects != null) {
            for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
                AnnotationObject paintObject = (AnnotationObject) iterator.next();
                if (paintObject instanceof AnnotationTextObject) {
                    ((AnnotationTextObject) paintObject).setFont(font);
                }
            }
            this.updatePanel();
        }
    }

    /**
     * Get paint objects
     *
     * @return
     */
    public List getPaintObjects() {
        return paintObjects;
    }

    /**
     * Get object image
     *
     * @param list
     * @return
     */
    public BufferedImage getObjectsImage(List list) {
        BufferedImage temp = new BufferedImage(img.getWidth(), img.getHeight(), BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2 = (Graphics2D) temp.getGraphics();
        for (Iterator iterator = list.iterator(); iterator.hasNext();) {
            AnnotationObject paintObject = (AnnotationObject) iterator.next();
            paintObject.addToGraphics(g2);
        }
        return temp;
    }

//    /**
//     * selecte all object on the screen
//     */
//    public void selectAll() {
//        this.setCurrentMode(MODE_SELECT);
//        for (Iterator iterator = paintObjects.iterator(); iterator.hasNext();) {
//            AnnotationObject paintObject = (AnnotationObject) iterator.next();
//            paintObject.setSelected(true);
//            selectedObjects.add(paintObject);
//            this.firePropertyChange("selection", null, selectedObjects);
//        }
//        this.updatePanel();
//    }
    public void textFinished(AnnotationTextObject textObject) {
        if (textObject.getText().trim().length() <= 0) {
            paintObjects.remove(textObject);
        }
        selectedObjects.remove(textObject);
        textObject.setSelected(false);
    }

    public void textFinished(AnnotationNoteObject noteObject) {
        if (noteObject.getText().trim().length() <= 0) {
            paintObjects.remove(noteObject);
        }
        selectedObjects.remove(noteObject);
        noteObject.setSelected(false);
    }

    /**
     * Add note object to the screen
     *
     * @param note
     */
    public void addNoteObjects(AnnotationNoteObject note) {
        //tempObjects.add(note);
        selectedObjects.add(note);
        paintObjects.add(note);
        this.setCurrentMode(MODE_NONE);
    }

    /**
     * Remove an note object that selected
     *
     * @param noteObj
     */
    public void removeSelectNote(AnnotationObject noteObj) {
        paintObjects.remove(noteObj);
        selectedObjects.remove(noteObj);
    }

    /**
     * Save an iamge and all annotion together
     *
     * @return
     */
    public boolean getPaintedImage() {
        File file = new File(System.getProperty("user.dir"), "temp" + File.separator + new Date().getTime() + ".png");
        if (file != null && file.getName().length() > 0) {
            ArrayList filters = ImageIOFileFilter.getImageWriterFilters();
            ImageIOFileFilter png = null;
            for (int i = 0; i < filters.size(); i++) {
                ImageIOFileFilter filter = (ImageIOFileFilter) filters.get(i);
                if (filter.getPreferredExtString().equalsIgnoreCase("png")) {
                    png = filter;
                    break;
                }
            }
            ImageWriter writer = png.getImageWriter();
            if (!file.getPath().endsWith("." + png.getPreferredExtString())) {
                file = new File(file.getPath() + "." + png.getPreferredExtString());
            }
//            this.currentFile = file;
            for (Iterator iterator = selectedObjects.iterator(); iterator.hasNext();) {
                AnnotationObject paintObject = (AnnotationObject) iterator.next();
                paintObject.setSelected(false);
            }
            selectedObjects.clear();
            BufferedImage save = new BufferedImage(img.getWidth(), img.getHeight(), png.getBiType());
            Graphics2D g = (Graphics2D) save.getGraphics();
            if (!png.isSupportsAlpha()) {
                g.setColor(this.bgColor);
                g.fillRect(0, 0, img.getWidth(), img.getHeight());
            }
            g.drawImage(img, 0, 0, null);
            g.drawImage(this.getObjectsImage(paintObjects), 0, 0, null);
            try {
                ImageOutputStream stream = new FileImageOutputStream(file);
                writer.setOutput(stream);
                writer.write(save);
                stream.close();
                return true;
            } catch (IOException e) {
                e.printStackTrace();
                return false;
            } finally {
                updatePanel();
            }
        }
        return false;
    }
}
